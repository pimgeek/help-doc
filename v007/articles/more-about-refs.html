<!DOCTYPE html>
<html>

  <head>
  <title>More About Refs</title>
  <meta content='text/html; charset=utf-8' http-equiv='Content-Type'>
  <meta content='width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no' name='viewport'>
  <meta name="description" content="© 2015 GitHub Inc. All rights reserved.
">

  <meta http-equiv="X-UA-Compatible" content="IE=edge">

  <link rel="stylesheet" href="/help-doc/v007/css/ui.css">
  <link rel="canonical" href="/help-doc/v007/articles/more-about-refs.html">
  <link rel="alternate" type="application/rss+xml" title="GitHub Help" href="/feed.xml" | prepend: site.baseurl | prepend: site.url }}" />
</head>


  <body class='app'>

    <div class='header'>
  <div class='container'>
    <div class='row'>
      <div class='col-pad-12'>
        <div class='site'>
          <a href="/help-doc/v007/">
            <span class='s0'>GitHub Help</span>
            <span class='s1'>Center</span>
          </a> 
<!--
          <div class="wrapper">

            <nav class="site-nav">
              <a href="#" class="menu-icon">
                <svg viewBox="0 0 18 15">
                  <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
                  <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
                  <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
                </svg>
              </a>

              <div class="trigger">
                
                  
                  <a class="page-link" href="/help-doc/v007/about/">About</a>
                  
                
                  
                
                  
                
                  
                  <a class="page-link" href="/help-doc/v007/search/index.html">Search</a>
                  
                
                  
                
              </div>
            </nav>

          </div>
-->
        </div>
      </div>
    </div>
  </div>
</div>



    <div class='container'>
      <div class='row'>
        <div class='sidebar col-pad-3'> 
          
  
  <div class='category'>
    <div class='name'>
      <a href="/help-doc/v007/categories/guides">Guides</a>
    </div>
    <div class='articles'>
      
      <div class='article'>
        <a class="post-link" href="/help-doc/v007/articles/why-react.html">Why React?</a>
        <!-- 如果当前文章有下属的子文章，就顺便列出它们 -->
        
        
        <!-- 子文档列表功能 增加的代码部分结束 -->
      </div>
      
      <div class='article'>
        <a class="post-link" href="/help-doc/v007/articles/displaying-data.html">Displaying Data</a>
        <!-- 如果当前文章有下属的子文章，就顺便列出它们 -->
        
        
          
          <ul>
  
    <li>
      <a class="post-link" href="/help-doc/v007/articles/jsx-in-depth.html">JSX in Depth</a>
    </li>
  
    <li>
      <a class="post-link" href="/help-doc/v007/articles/jsx-spread.html">JSX Spread</a>
    </li>
  
    <li>
      <a class="post-link" href="/help-doc/v007/articles/jsx-gotchas.html">JSX Gotchas</a>
    </li>
  
</ul>

        
        <!-- 子文档列表功能 增加的代码部分结束 -->
      </div>
      
      <div class='article'>
        <a class="post-link" href="/help-doc/v007/articles/interactivity-and-dynamic-uis.html">Interactivity and Dynamic UIs</a>
        <!-- 如果当前文章有下属的子文章，就顺便列出它们 -->
        
        
        <!-- 子文档列表功能 增加的代码部分结束 -->
      </div>
      
      <div class='article'>
        <a class="post-link" href="/help-doc/v007/articles/multiple-components.html">Multiple Components</a>
        <!-- 如果当前文章有下属的子文章，就顺便列出它们 -->
        
        
        <!-- 子文档列表功能 增加的代码部分结束 -->
      </div>
      
      <div class='article'>
        <a class="post-link" href="/help-doc/v007/articles/reusable-components.html">Reusable Components</a>
        <!-- 如果当前文章有下属的子文章，就顺便列出它们 -->
        
        
        <!-- 子文档列表功能 增加的代码部分结束 -->
      </div>
      
      <div class='article'>
        <a class="post-link" href="/help-doc/v007/articles/transferring-props.html">Transferring Props</a>
        <!-- 如果当前文章有下属的子文章，就顺便列出它们 -->
        
        
        <!-- 子文档列表功能 增加的代码部分结束 -->
      </div>
      
      <div class='article'>
        <a class="post-link" href="/help-doc/v007/articles/forms.html">Forms</a>
        <!-- 如果当前文章有下属的子文章，就顺便列出它们 -->
        
        
        <!-- 子文档列表功能 增加的代码部分结束 -->
      </div>
      
      <div class='article'>
        <a class="post-link" href="/help-doc/v007/articles/working-with-the-browser.html">Working with the Browser</a>
        <!-- 如果当前文章有下属的子文章，就顺便列出它们 -->
        
        
          
          <ul>
  
    <li>
      <a class="post-link" href="/help-doc/v007/articles/more-about-refs.html">More About Refs</a>
    </li>
  
</ul>

        
        <!-- 子文档列表功能 增加的代码部分结束 -->
      </div>
      
      <div class='article'>
        <a class="post-link" href="/help-doc/v007/articles/tooling-integration.html">Tooling Integration</a>
        <!-- 如果当前文章有下属的子文章，就顺便列出它们 -->
        
        
        <!-- 子文档列表功能 增加的代码部分结束 -->
      </div>
      
      <div class='article'>
        <a class="post-link" href="/help-doc/v007/articles/addons.html">Addons</a>
        <!-- 如果当前文章有下属的子文章，就顺便列出它们 -->
        
        
          
          <ul>
  
    <li>
      <a class="post-link" href="/help-doc/v007/articles/animation.html">Animation</a>
    </li>
  
    <li>
      <a class="post-link" href="/help-doc/v007/articles/two-way-binding-helpers.html">Two-Way Binding Helpers</a>
    </li>
  
    <li>
      <a class="post-link" href="/help-doc/v007/articles/class-name-manipulation.html">Class Name Manipulation</a>
    </li>
  
    <li>
      <a class="post-link" href="/help-doc/v007/articles/test-utilities.html">Test Utilities</a>
    </li>
  
    <li>
      <a class="post-link" href="/help-doc/v007/articles/cloning-reactelements.html">Cloning ReactElements</a>
    </li>
  
    <li>
      <a class="post-link" href="/help-doc/v007/articles/keyed-fragments.html">Keyed Fragments</a>
    </li>
  
    <li>
      <a class="post-link" href="/help-doc/v007/articles/immutability-helpers.html">Immutability Helpers</a>
    </li>
  
    <li>
      <a class="post-link" href="/help-doc/v007/articles/pure-render-mixin.html">Pure Render Mixin</a>
    </li>
  
    <li>
      <a class="post-link" href="/help-doc/v007/articles/performance-tools.html">Performance Tools</a>
    </li>
  
</ul>

        
        <!-- 子文档列表功能 增加的代码部分结束 -->
      </div>
      
      <div class='article'>
        <a class="post-link" href="/help-doc/v007/articles/advanced-performance.html">Advanced Performance</a>
        <!-- 如果当前文章有下属的子文章，就顺便列出它们 -->
        
        
        <!-- 子文档列表功能 增加的代码部分结束 -->
      </div>
      
    </div>
  </div>


        </div>
        <div class='main col-pad-9'>

          <!-- 注意，如果发布到 github pages 时采用了 gh-pages 方式，那么下列代码中的 /search, /js 等路径需要增加 /help-doc/v007 前缀 -->
<div id="search">
  <h2>
  <form action="/help-doc/v007/search" method="get">
    <input type="text" id="search-query" name="q" placeholder="Search" autocomplete="off">
  </form>
  </h2>
</div>
<section id="search-results" style="display: none;">
  <h3>Search results</h3>
  <div class="entries">
  </div>
</section>

<script id="search-results-template" type="text/mustache">
  {{#entries}}
    <article>
      <h3>
        <a href="{{{ site.baseurl }}}{{url}}">{{title}}</a>
      </h3>
    </article>
  {{/entries}}
</script>

<script src="/help-doc/v007/js/search.min.js" type="text/javascript" charset="utf-8"></script>
<script type="text/javascript">
  $(function() {
    $('#search-query').lunrSearch({
      indexUrl: '/help-doc/v007/js/index.json',   // Url for the .json file containing search index data
      results : '#search-results',  // selector for containing search results element
      entries : '.entries',         // selector for search entries containing element (contained within results above)
      template: '#search-results-template'  // selector for Mustache.js template
    });
  });
</script>


          <h1>More About Refs</h1>
<p></p>

<p>After returning the structure of your UI from the render method, you may find yourself wanting to “reach out” and invoke methods on component instances returned from render. Often, doing something like this isn’t necessary for making data flow through your application, because the Reactive data flow always ensures that the most recent <code>props</code> are sent to each child that is output from <code>render()</code>. However, there are a few cases where it still might be necessary or beneficial.</p>

<p>Consider the case, when you wish to tell an <code>&lt;input /&gt;</code> element (that exists within your instances sub-hierarchy) to focus after you update its value to be the empty string, <code>''</code>.</p>

<p><code>javascript
  var App = React.createClass({
    getInitialState: function() {
      return {userInput: ''};
    },
    handleChange: function(e) {
      this.setState({userInput: e.target.value});
    },
    clearAndFocusInput: function() {
      this.setState({userInput: ''}); // Clear the input
      // We wish to focus the &lt;input /&gt; now!
    },
    render: function() {
      return (
        &lt;div&gt;
          &lt;div onClick={this.clearAndFocusInput}&gt;
            Click to Focus and Reset
          &lt;/div&gt;
          &lt;input
            value={this.state.userInput}
            onChange={this.handleChange}
          /&gt;
        &lt;/div&gt;
      );
    }
  });
</code></p>

<p>Notice how, in this example, we want to “tell” the input something - something that it cannot infer from its props over time. In this case we want to “tell” it that it should now become focused. However, there are some challenges. What is returned from <code>render()</code> is not your actual composition of “child” components, but rather it is a <em>description</em> of the children at a particular instance in time - a snapshot.</p>

<blockquote>
  <p>Note:</p>

  <p>Remember, what you return from <code>render()</code> is not your <em>actual</em> rendered children instances. What you return from <code>render()</code> is merely a <em>description</em> of the children instances in your component’s sub-hierarchy at a particular moment in time.</p>
</blockquote>

<p>This means that you should never “hold onto” something that you return from <code>render()</code> and then expect it to be anything meaningful.</p>

<p><code>javascript
  // counterexample: DO NOT DO THIS!
  render: function() {
    var myInput = &lt;input /&gt;;          // I'm going to try to call methods on this
    this.rememberThisInput = myInput; // input at some point in the future! YAY!
    return (
      &lt;div&gt;
        &lt;div&gt;...&lt;/div&gt;
        {myInput}
      &lt;/div&gt;
    );
  }
</code></p>

<p>In this counterexample, the <code>&lt;input /&gt;</code> is merely a <em>description</em> of an <code>&lt;input /&gt;</code>. This description is used to create a <em>real</em> <strong>backing instance</strong> for the <code>&lt;input /&gt;</code>.</p>

<p>So how do we talk to the <em>real</em> backing instance of the input?</p>

<h2 id="the-ref-string-attribute">The ref String Attribute</h2>

<p>React supports a very special property that you can attach to any component that is output from <code>render()</code>. This special property allows you to refer to the corresponding <strong>backing instance</strong> of anything returned from <code>render()</code>. It is always guaranteed to be the proper instance, at any point in time.</p>

<p>It’s as simple as:</p>

<ol>
  <li>Assign a <code>ref</code> attribute to anything returned from <code>render</code> such as:</li>
</ol>

<p><code>html
  &lt;input ref="myInput" /&gt;
 </code></p>

<ol>
  <li>In some other code (typically event handler code), access the <strong>backing instance</strong> via <code>this.refs</code> as in:</li>
</ol>

<p><code>javascript
  this.refs.myInput
 </code></p>

<p>You can access the component’s DOM node directly by calling <code>React.findDOMNode(this.refs.myInput)</code>.</p>

<h2 id="the-ref-callback-attribute">The ref Callback Attribute</h2>

<p>The <code>ref</code> attribute can be a callback function instead of a name.  This callback will be executed immediately after the component is mounted.  The referenced component will be passed in as a parameter, and the callback function may use the component immediately, or save the reference for future use (or both).</p>

<p>It’s as simple as assigning a <code>ref</code> attribute to anything returned from <code>render</code> such as:</p>

<p><code>html
  &lt;input ref={ function(component){ React.findDOMNode(component).focus();} } /&gt;
 </code></p>

<h2 id="completing-the-example">Completing the Example</h2>

<p><code>javascript
  var App = React.createClass({
    getInitialState: function() {
      return {userInput: ''};
    },
    handleChange: function(e) {
      this.setState({userInput: e.target.value});
    },
    clearAndFocusInput: function() {
      // Clear the input
      this.setState({userInput: ''}, function() {
        // This code executes after the component is re-rendered
        React.findDOMNode(this.refs.theInput).focus();   // Boom! Focused!
      });
    },
    render: function() {
      return (
        &lt;div&gt;
          &lt;div onClick={this.clearAndFocusInput}&gt;
            Click to Focus and Reset
          &lt;/div&gt;
          &lt;input
            ref="theInput"
            value={this.state.userInput}
            onChange={this.handleChange}
          /&gt;
        &lt;/div&gt;
      );
    }
  });
</code></p>

<p>In this example, our render function returns a description of an <code>&lt;input /&gt;</code> instance. But the true instance is accessed via <code>this.refs.theInput</code>. As long as a child component with <code>ref="theInput"</code> is returned from render, <code>this.refs.theInput</code> will access the proper instance. This even works on higher level (non-DOM) components such as <code>&lt;Typeahead ref="myTypeahead" /&gt;</code>.</p>

<h2 id="summary">Summary</h2>

<p>Refs are a great way to send a message to a particular child instance in a way that would be inconvenient to do via streaming Reactive <code>props</code> and <code>state</code>. They should, however, not be your go-to abstraction for flowing data through your application. By default, use the Reactive data flow and save <code>ref</code>s for use cases that are inherently non-reactive.</p>

<h3 id="benefits">Benefits:</h3>

<ul>
  <li>You can define any public method on your component classes (such as a reset method on a Typeahead) and call those public methods through refs (such as <code>this.refs.myTypeahead.reset()</code>).</li>
  <li>Performing DOM measurements almost always requires reaching out to a “native” component such as <code>&lt;input /&gt;</code> and accessing its underlying DOM node via <code>React.findDOMNode(this.refs.myInput)</code>. Refs are one of the only practical ways of doing this reliably.</li>
  <li>Refs are automatically managed for you! If that child is destroyed, its ref is also destroyed for you. No worrying about memory here (unless you do something crazy to retain a reference yourself).</li>
</ul>

<h3 id="cautions">Cautions:</h3>

<ul>
  <li><em>Never</em> access refs inside of any component’s render method - or while any component’s render method is even running anywhere in the call stack.</li>
  <li>If you want to preserve Google Closure Compiler Crushing resilience, make sure to never access as a property what was specified as a string. This means you must access using <code>this.refs['myRefString']</code> if your ref was defined as <code>ref="myRefString"</code>.</li>
  <li>If you have not programmed several apps with React, your first inclination is usually going to be to try to use refs to “make things happen” in your app. If this is the case, take a moment and think more critically about where <code>state</code> should be owned in the component hierarchy. Often, it becomes clear that the proper place to “own” that state is at a higher level in the hierarchy. Placing the state there often eliminates any desire to use <code>ref</code>s to “make things happen” – instead, the data flow will usually accomplish your goal.</li>
</ul>



  
  <h2>
    prev post: <a href='/help-doc/v007/articles/working-with-the-browser.html'>working-with-the-browser.html</a>
  </h2>


  
  <h2>
    next post: <a href='/help-doc/v007/articles/tooling-integration.html'>tooling-integration.html</a>
  </h2>




        </div>

      </div>
      <div class='row'>

        <div class='team'>GitHub Help</div>
<a class='link' href='mailto:support@github.com' target='_blank'>support@github.com</a>
<div class="footer-col  footer-col-3">
  <p class="text">© 2015 GitHub Inc. All rights reserved.
</p>
</div>


      </div>
    </div>

  </body>
</html>
