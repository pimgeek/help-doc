<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>GitHub Help</title>
    <description>© 2015 GitHub Inc. All rights reserved.
</description>
    <link>/help-doc/v006/</link>
    <atom:link href="/help-doc/v006/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Fri, 03 Jul 2015 01:04:26 +0800</pubDate>
    <lastBuildDate>Fri, 03 Jul 2015 01:04:26 +0800</lastBuildDate>
    <generator>Jekyll v2.5.3</generator>
    
      <item>
        <title>Advanced Performance</title>
        <description>&lt;p&gt;One of the first questions people ask when considering React for a project is whether their application will be as fast and responsive as an equivalent non-React version. The idea of re-rendering an entire subtree of components in response to every state change makes people wonder whether this process negatively impacts performance. React uses several clever techniques to minimize the number of costly DOM operations required to update the UI.&lt;/p&gt;

&lt;h2 id=&quot;avoiding-reconciling-the-dom&quot;&gt;Avoiding reconciling the DOM&lt;/h2&gt;

&lt;p&gt;React makes use of a &lt;em&gt;virtual DOM&lt;/em&gt;, which is a descriptor of a DOM subtree rendered in the browser. This parallel representation allows React to avoid creating DOM nodes and accessing existing ones, which is slower than operations on JavaScript objects. When a component’s props or state change, React decides whether an actual DOM update is necessary by constructing a new virtual DOM and comparing it to the old one. Only in the case they are not equal, will React &lt;a href=&quot;/react/docs/reconciliation.html&quot;&gt;reconcile&lt;/a&gt; the DOM, applying as few mutations as possible.&lt;/p&gt;

&lt;p&gt;On top of this, React provides a component lifecycle function, &lt;code&gt;shouldComponentUpdate&lt;/code&gt;, which is triggered before the re-rendering process starts (virtual DOM comparison and possible eventual DOM reconciliation), giving the developer the ability to short circuit this process. The default implementation of this function returns &lt;code&gt;true&lt;/code&gt;, leaving React to perform the update:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;javascript
shouldComponentUpdate: function(nextProps, nextState) {
  return true;
}
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Keep in mind that React will invoke this function pretty often, so the implementation has to be fast.&lt;/p&gt;

&lt;p&gt;Say you have a messaging application with several chat threads. Suppose only one of the threads has changed. If we implement &lt;code&gt;shouldComponentUpdate&lt;/code&gt; on the &lt;code&gt;ChatThread&lt;/code&gt; component, React can skip the rendering step for the other threads:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;javascript
shouldComponentUpdate: function(nextProps, nextState) {
  // TODO: return whether or not current chat thread is
  // different to former one.
}
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;So, in summary, React avoids carrying out expensive DOM operations required to reconcile subtrees of the DOM by allowing the user to short circuit the process using &lt;code&gt;shouldComponentUpdate&lt;/code&gt;, and, for those which should update, by comparing virtual DOMs.&lt;/p&gt;

&lt;h2 id=&quot;shouldcomponentupdate-in-action&quot;&gt;shouldComponentUpdate in action&lt;/h2&gt;

&lt;p&gt;Here’s a subtree of components. For each one is indicated what &lt;code&gt;shouldComponentUpdate&lt;/code&gt; returned and whether or not the virtual DOMs were equivalent. Finally, the circle’s color indicates whether the component had to be reconciled or not.&lt;/p&gt;

&lt;figure&gt;&lt;img src=&quot;/react/img/docs/should-component-update.png&quot; /&gt;&lt;/figure&gt;

&lt;p&gt;In the example above, since &lt;code&gt;shouldComponentUpdate&lt;/code&gt; returned &lt;code&gt;false&lt;/code&gt; for the subtree rooted at C2, React had no need to generate the new virtual DOM, and therefore, it neither needed to reconcile the DOM. Note that React didn’t even have to invoke &lt;code&gt;shouldComponentUpdate&lt;/code&gt; on C4 and C5.&lt;/p&gt;

&lt;p&gt;For C1 and C3 &lt;code&gt;shouldComponentUpdate&lt;/code&gt; returned &lt;code&gt;true&lt;/code&gt;, so React had to go down to the leaves and check them. For C6 it returned &lt;code&gt;true&lt;/code&gt;; since the virtual DOMs weren’t equivalent it had to reconcile the DOM.
The last interesting case is C8. For this node React had to compute the virtual DOM, but since it was equal to the old one, it didn’t have to reconcile it’s DOM.&lt;/p&gt;

&lt;p&gt;Note that React only had to do DOM mutations for C6, which was inevitable. For C8, it bailed out by comparing the virtual DOMs, and for C2’s subtree and C7, it didn’t even have to compute the virtual DOM as we bailed out on &lt;code&gt;shouldComponentUpdate&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;So, how should we implement &lt;code&gt;shouldComponentUpdate&lt;/code&gt;? Say that you have a component that just renders a string value:&lt;/p&gt;

&lt;p&gt;```javascript
React.createClass({
  propTypes: {
    value: React.PropTypes.string.isRequired
  },&lt;/p&gt;

&lt;p&gt;render: function() {
    return &amp;lt;div&amp;gt;this.props.value&amp;lt;/div&amp;gt;;
  }
});
```&lt;/p&gt;

&lt;p&gt;We could easily implement &lt;code&gt;shouldComponentUpdate&lt;/code&gt; as follow:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;javascript
shouldComponentUpdate: function(nextProps, nextState) {
  return this.props.value !== nextProps.value;
}
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;So far so good, dealing with such simple props/state structures is easy. We could even generalize an implementation based on shallow equality and mix it into components. In fact, React already provides such implementation: &lt;a href=&quot;/react/docs/pure-render-mixin.html&quot;&gt;PureRenderMixin&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;But what if your components’ props or state are mutable data structures?. Say the prop the component receives, instead of being a string like &lt;code&gt;&#39;bar&#39;&lt;/code&gt;, is a Javascript object that contains a string such as, &lt;code&gt;{ foo: &#39;bar&#39; }&lt;/code&gt;:&lt;/p&gt;

&lt;p&gt;```javascript
React.createClass({
  propTypes: {
    value: React.PropTypes.object.isRequired
  },&lt;/p&gt;

&lt;p&gt;render: function() {
    return &amp;lt;div&amp;gt;this.props.value.foo&amp;lt;/div&amp;gt;;
  }
});
```&lt;/p&gt;

&lt;p&gt;The implementation of &lt;code&gt;shouldComponentUpdate&lt;/code&gt; we had before wouldn’t always work as expected:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;javascript
// assume this.props.value is { foo: &#39;bar&#39; }
// assume nextProps.value is { foo: &#39;bar&#39; },
// but this reference is different to this.props.value
this.props.value !== nextProps.value; // true
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;The problem is &lt;code&gt;shouldComponentUpdate&lt;/code&gt; will return &lt;code&gt;true&lt;/code&gt; when the prop actually didn’t change. To fix this, we could come up with this alternative implementation:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;javascript
shouldComponentUpdate: function(nextProps, nextState) {
  return this.props.value.foo !== nextProps.value.foo;
}
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Basically, we ended up doing a deep comparison to make sure we properly track changes. In terms of performance, this approach is pretty expensive. It doesn’t scale as we would have to write different deep equality code for each model. On top of that, it might not even work if we don’t carefully manage object references. Say this component is used by a parent:&lt;/p&gt;

&lt;p&gt;```javascript
React.createClass({
  getInitialState: function() {
    return { value: { foo: ‘bar’ } };
  },&lt;/p&gt;

&lt;p&gt;onClick: function() {
    var value = this.state.value;
    value.foo += ‘bar’; // ANTI-PATTERN!
    this.setState({ value: value });
  },&lt;/p&gt;

&lt;p&gt;render: function() {
    return (
      &amp;lt;div&amp;gt;
        &amp;lt;InnerComponent value={this.state.value} /&amp;gt;
        &amp;lt;a onClick={this.onClick}&amp;gt;Click me&amp;lt;/a&amp;gt;
      &amp;lt;/div&amp;gt;
    );
  }
});
```&lt;/p&gt;

&lt;p&gt;The first time the inner component gets rendered, it will have &lt;code&gt;{ foo: &#39;bar&#39; }&lt;/code&gt; as the value prop. If the user clicks on the anchor, the parent component’s state will get updated to &lt;code&gt;{ value: { foo: &#39;barbar&#39; } }&lt;/code&gt;, triggering the re-rendering process of the inner component, which will receive &lt;code&gt;{ foo: &#39;barbar&#39; }&lt;/code&gt; as the new value for the prop.&lt;/p&gt;

&lt;p&gt;The problem is that since the parent and inner components share a reference to the same object, when the object gets mutated on line 2 of the &lt;code&gt;onClick&lt;/code&gt; function, the prop the inner component had will change. So, when the re-rendering process starts, and &lt;code&gt;shouldComponentUpdate&lt;/code&gt; gets invoked, &lt;code&gt;this.props.value.foo&lt;/code&gt; will be equal to &lt;code&gt;nextProps.value.foo&lt;/code&gt;, because in fact, &lt;code&gt;this.props.value&lt;/code&gt; references the same object as &lt;code&gt;nextProps.value&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Consequently, since we’ll miss the change on the prop and short circuit the re-rendering process, the UI won’t get updated from &lt;code&gt;&#39;bar&#39;&lt;/code&gt; to &lt;code&gt;&#39;barbar&#39;&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&quot;immutable-js-to-the-rescue&quot;&gt;Immutable-js to the rescue&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/facebook/immutable-js&quot;&gt;Immutable-js&lt;/a&gt; is a Javascript collections library  written by Lee Byron, which Facebook recently open-sourced. It provides &lt;em&gt;immutable persistent&lt;/em&gt; collections via &lt;em&gt;structural sharing&lt;/em&gt;. Lets see what these properties mean:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;em&gt;Immutable&lt;/em&gt;: once created, a collection cannot be altered at another point in time.&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;Persistent&lt;/em&gt;: new collections can be created from a previous collection and a mutation such as set. The original collection is still valid after the new collection is created.&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;Structural Sharing&lt;/em&gt;: new collections are created using as much of the same structure as the original collection as possible, reducing copying to a minimum to achieve space efficiency and acceptable performance. If the new collection is equal to the original, the original is often returned.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Immutability makes tracking changes cheap; a change will always result in a new object so we only need to check if the reference to the object has changed. For example, in this regular Javascript code:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;javascript
var x = { foo: &quot;bar&quot; };
var y = x;
y.foo = &quot;baz&quot;;
x === y; // true
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Although &lt;code&gt;y&lt;/code&gt; was edited, since it’s a reference to the same object as &lt;code&gt;x&lt;/code&gt;, this comparison returns &lt;code&gt;true&lt;/code&gt;. However, this code could be written using immutable-js as follows:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;javascript
var SomeRecord = Immutable.Record({ foo: null });
var x = new SomeRecord({ foo: &#39;bar&#39;  });
var y = x.set(&#39;foo&#39;, &#39;baz&#39;);
x === y; // false
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;In this case, since a new reference is returned when mutating &lt;code&gt;x&lt;/code&gt;, we can safely assume that &lt;code&gt;x&lt;/code&gt; has changed.&lt;/p&gt;

&lt;p&gt;Another possible way to track changes could be doing dirty checking by having a flag set by setters. A problem with this approach is that it forces you to use setters and, either write a lot of additional code, or somehow instrument your classes. Alternatively, you could deep copy the object just before the mutations and deep compare to determine whether there was a change or not. A problem with this approach is both deepCopy and deepCompare are expensive operations.&lt;/p&gt;

&lt;p&gt;So, Immutable data structures provides you a cheap and less verbose way to track changes on objects, which is all we need to implement &lt;code&gt;shouldComponentUpdate&lt;/code&gt;. Therefore, if we model props and state attributes using the abstractions provided by immutable-js we’ll be able to use &lt;code&gt;PureRenderMixin&lt;/code&gt; and get a nice boost in perf.&lt;/p&gt;

&lt;h2 id=&quot;immutable-js-and-flux&quot;&gt;Immutable-js and Flux&lt;/h2&gt;

&lt;p&gt;If you’re using &lt;a href=&quot;https://facebook.github.io/flux/&quot;&gt;Flux&lt;/a&gt;, you should start writing your stores using immutable-js. Take a look at the &lt;a href=&quot;https://facebook.github.io/immutable-js/docs/#/&quot;&gt;full API&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Let’s see one possible way to model the thread example using Immutable data structures. First, we need to define a &lt;code&gt;Record&lt;/code&gt; for each of the entities we’re trying to model. Records are just immutable containers that hold values for a specific set of fields:&lt;/p&gt;

&lt;p&gt;```javascript
var User = Immutable.Record({
  id: undefined,
  name: undefined,
  email: undefined
});&lt;/p&gt;

&lt;p&gt;var Message = Immutable.Record({
  timestamp: new Date(),
  sender: undefined,
  text: ‘’
});
```&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;Record&lt;/code&gt; function receives an object that defines the fields the object has and its default values.&lt;/p&gt;

&lt;p&gt;The messages &lt;em&gt;store&lt;/em&gt; could keep track of the users and messages using two lists:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;javascript
this.users = Immutable.List();
this.messages = Immutable.List();
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;It should be pretty straightforward to implement functions to process each &lt;em&gt;payload&lt;/em&gt; type. For instance, when the store sees a payload representing a new message,  we can just create a new record and append it to the messages list:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;javascript
this.messages = this.messages.push(new Message({
  timestamp: payload.timestamp,
  sender: payload.sender,
  text: payload.text
});
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Note that since the data structures are immutable, we need to assign the result of the push function to &lt;code&gt;this.messages&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;On the React side, if we also use immutable-js data structures to hold the components’ state, we could mix &lt;code&gt;PureRenderMixin&lt;/code&gt; into all our components and short circuit the re-rendering process.&lt;/p&gt;
</description>
        <pubDate>Tue, 01 Jan 3011 00:00:00 +0800</pubDate>
        <link>/help-doc/v006/articles/advanced-performance.html</link>
        <guid isPermaLink="true">/help-doc/v006/articles/advanced-performance.html</guid>
        
        
        <category>guides</category>
        
      </item>
    
      <item>
        <title>Addons</title>
        <description>&lt;p&gt;&lt;code&gt;React.addons&lt;/code&gt; is where we park some useful utilities for building React apps. &lt;strong&gt;These should be considered experimental&lt;/strong&gt; but will eventually be rolled into core or a blessed utilities library:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;animation.html&quot;&gt;&lt;code&gt;TransitionGroup&lt;/code&gt; and &lt;code&gt;CSSTransitionGroup&lt;/code&gt;&lt;/a&gt;, for dealing with animations and transitions that are usually not simple to implement, such as before a component’s removal.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;two-way-binding-helpers.html&quot;&gt;&lt;code&gt;LinkedStateMixin&lt;/code&gt;&lt;/a&gt;, to simplify the coordination between user’s form input data and the component’s state.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;clone-with-props.html&quot;&gt;&lt;code&gt;cloneWithProps&lt;/code&gt;&lt;/a&gt;, to make shallow copies of React components and change their props.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;create-fragment.html&quot;&gt;&lt;code&gt;createFragment&lt;/code&gt;&lt;/a&gt;, to create a set of externally-keyed children.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;update.html&quot;&gt;&lt;code&gt;update&lt;/code&gt;&lt;/a&gt;, a helper function that makes dealing with immutable data in JavaScript easier.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;pure-render-mixin.html&quot;&gt;&lt;code&gt;PureRenderMixin&lt;/code&gt;&lt;/a&gt;, a performance booster under certain situations.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The add-ons below are in the development (unminified) version of React only:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;test-utils.html&quot;&gt;&lt;code&gt;TestUtils&lt;/code&gt;&lt;/a&gt;, simple helpers for writing test cases (unminified build only).&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;perf.html&quot;&gt;&lt;code&gt;Perf&lt;/code&gt;&lt;/a&gt;, for measuring performance and giving you hint where to optimize.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;To get the add-ons, use &lt;code&gt;react-with-addons.js&lt;/code&gt; (and its minified counterpart) rather than the common &lt;code&gt;react.js&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;When using the react package from npm, simply &lt;code&gt;require(&#39;react/addons&#39;)&lt;/code&gt; instead of &lt;code&gt;require(&#39;react&#39;)&lt;/code&gt; to get React with all of the add-ons.&lt;/p&gt;

&lt;ul&gt;
  
&lt;/ul&gt;

</description>
        <pubDate>Mon, 01 Jan 3010 00:00:00 +0800</pubDate>
        <link>/help-doc/v006/articles/addons.html</link>
        <guid isPermaLink="true">/help-doc/v006/articles/addons.html</guid>
        
        
        <category>guides</category>
        
      </item>
    
      <item>
        <title>Tooling Integration</title>
        <description>&lt;p&gt;Every project uses a different system for building and deploying JavaScript. We’ve tried to make React as environment-agnostic as possible.&lt;/p&gt;

&lt;h2 id=&quot;react&quot;&gt;React&lt;/h2&gt;

&lt;h3 id=&quot;cdn-hosted-react&quot;&gt;CDN-hosted React&lt;/h3&gt;

&lt;p&gt;We provide CDN-hosted versions of React &lt;a href=&quot;/react/downloads.html&quot;&gt;on our download page&lt;/a&gt;. These prebuilt files use the UMD module format. Dropping them in with a simple &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tag will inject a &lt;code&gt;React&lt;/code&gt; global into your environment. It should also work out-of-the-box in CommonJS and AMD environments.&lt;/p&gt;

&lt;h3 id=&quot;using-master&quot;&gt;Using master&lt;/h3&gt;

&lt;p&gt;We have instructions for building from &lt;code&gt;master&lt;/code&gt; &lt;a href=&quot;https://github.com/facebook/react&quot;&gt;in our GitHub repository&lt;/a&gt;. We build a tree of CommonJS modules under &lt;code&gt;build/modules&lt;/code&gt; which you can drop into any environment or packaging tool that supports CommonJS.&lt;/p&gt;

&lt;h2 id=&quot;jsx&quot;&gt;JSX&lt;/h2&gt;

&lt;h3 id=&quot;in-browser-jsx-transform&quot;&gt;In-browser JSX Transform&lt;/h3&gt;

&lt;p&gt;If you like using JSX, we provide an in-browser JSX transformer for development &lt;a href=&quot;/react/downloads.html&quot;&gt;on our download page&lt;/a&gt;. Simply include a &lt;code&gt;&amp;lt;script type=&quot;text/jsx&quot;&amp;gt;&lt;/code&gt; tag to engage the JSX transformer.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Note:&lt;/p&gt;

  &lt;p&gt;The in-browser JSX transformer is fairly large and results in extraneous computation client-side that can be avoided. Do not use it in production — see the next section.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;productionizing-precompiled-jsx&quot;&gt;Productionizing: Precompiled JSX&lt;/h3&gt;

&lt;p&gt;If you have &lt;a href=&quot;https://www.npmjs.com/&quot;&gt;npm&lt;/a&gt;, you can simply run &lt;code&gt;npm install -g react-tools&lt;/code&gt; to install our command-line &lt;code&gt;jsx&lt;/code&gt; tool. This tool will translate files that use JSX syntax to plain JavaScript files that can run directly in the browser. It will also watch directories for you and automatically transform files when they are changed; for example: &lt;code&gt;jsx --watch src/ build/&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;By default JSX files with a &lt;code&gt;.js&lt;/code&gt; extension are transformed. Use &lt;code&gt;jsx --extension jsx src/ build/&lt;/code&gt; to transform files with a &lt;code&gt;.jsx&lt;/code&gt; extension.&lt;/p&gt;

&lt;p&gt;Run &lt;code&gt;jsx --help&lt;/code&gt; for more information on how to use this tool.&lt;/p&gt;

&lt;h3 id=&quot;helpful-open-source-projects&quot;&gt;Helpful Open-Source Projects&lt;/h3&gt;

&lt;p&gt;The open-source community has built tools that integrate JSX with several editors and build systems. See &lt;a href=&quot;https://github.com/facebook/react/wiki/Complementary-Tools#jsx-integrations&quot;&gt;JSX integrations&lt;/a&gt; for the full list.&lt;/p&gt;
</description>
        <pubDate>Sun, 01 Jan 3009 00:00:00 +0800</pubDate>
        <link>/help-doc/v006/articles/tooling-integration.html</link>
        <guid isPermaLink="true">/help-doc/v006/articles/tooling-integration.html</guid>
        
        
        <category>guides</category>
        
      </item>
    
      <item>
        <title>Working with the Browser</title>
        <description>&lt;p&gt;React provides powerful abstractions that free you from touching the DOM directly in most cases, but sometimes you simply need to access the underlying API, perhaps to work with a third-party library or existing code.&lt;/p&gt;

&lt;h2 id=&quot;the-virtual-dom&quot;&gt;The Virtual DOM&lt;/h2&gt;

&lt;p&gt;React is so fast because it never talks to the DOM directly. React maintains a fast in-memory representation of the DOM. &lt;code&gt;render()&lt;/code&gt; methods return a &lt;em&gt;description&lt;/em&gt; of the DOM, and React can diff this description with the in-memory representation to compute the fastest way to update the browser.&lt;/p&gt;

&lt;p&gt;Additionally, React implements a full synthetic event system such that all event objects are guaranteed to conform to the W3C spec despite browser quirks, and everything bubbles consistently and efficiently across browsers. You can even use some HTML5 events in IE8!&lt;/p&gt;

&lt;p&gt;Most of the time you should stay within React’s “faked browser” world since it’s more performant and easier to reason about. However, sometimes you simply need to access the underlying API, perhaps to work with a third-party library like a jQuery plugin. React provides escape hatches for you to use the underlying DOM API directly.&lt;/p&gt;

&lt;h2 id=&quot;refs-and-finddomnode&quot;&gt;Refs and findDOMNode()&lt;/h2&gt;

&lt;p&gt;To interact with the browser, you’ll need a reference to a DOM node. React has a &lt;code&gt;React.findDOMNode(component)&lt;/code&gt; function which you can call to get a reference to the component’s DOM node.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Note:&lt;/p&gt;

  &lt;p&gt;&lt;code&gt;findDOMNode()&lt;/code&gt; only works on mounted components (that is, components that have been placed in the DOM). If you try to call this on a component that has not been mounted yet (like calling &lt;code&gt;findDOMNode()&lt;/code&gt; in &lt;code&gt;render()&lt;/code&gt; on a component that has yet to be created) an exception will be thrown.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;In order to get a reference to a React component, you can either use &lt;code&gt;this&lt;/code&gt; to get the current React component, or you can use refs to refer to a component you own. They work like this:&lt;/p&gt;

&lt;p&gt;```javascript
var MyComponent = React.createClass({
  handleClick: function() {
    // Explicitly focus the text input using the raw DOM API.
    React.findDOMNode(this.refs.myTextInput).focus();
  },
  render: function() {
    // The ref attribute adds a reference to the component to
    // this.refs when the component is mounted.
    return (
      &amp;lt;div&amp;gt;
        &lt;input type=&quot;text&quot; ref=&quot;myTextInput&quot; /&gt;
        &amp;lt;input
          type=”button”
          value=”Focus the text input”
          onClick={this.handleClick}
        /&amp;gt;
      &amp;lt;/div&amp;gt;
    );
  }
});&lt;/p&gt;

&lt;p&gt;React.render(&lt;/p&gt;
&lt;mycomponent /&gt;
&lt;p&gt;,
  document.getElementById(‘example’)
);
```&lt;/p&gt;

&lt;h2 id=&quot;more-about-refs&quot;&gt;More About Refs&lt;/h2&gt;

&lt;p&gt;To learn more about refs, including ways to use them effectively, see our &lt;a href=&quot;/react/docs/more-about-refs.html&quot;&gt;more about refs&lt;/a&gt; documentation.&lt;/p&gt;

&lt;h2 id=&quot;component-lifecycle&quot;&gt;Component Lifecycle&lt;/h2&gt;

&lt;p&gt;Components have three main parts of their lifecycle:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Mounting:&lt;/strong&gt; A component is being inserted into the DOM.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Updating:&lt;/strong&gt; A component is being re-rendered to determine if the DOM should be updated.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Unmounting:&lt;/strong&gt; A component is being removed from the DOM.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;React provides lifecycle methods that you can specify to hook into this process. We provide &lt;strong&gt;will&lt;/strong&gt; methods, which are called right before something happens, and &lt;strong&gt;did&lt;/strong&gt; methods which are called right after something happens.&lt;/p&gt;

&lt;h3 id=&quot;mounting&quot;&gt;Mounting&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;getInitialState(): object&lt;/code&gt; is invoked before a component is mounted. Stateful components should implement this and return the initial state data.&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;componentWillMount()&lt;/code&gt; is invoked immediately before mounting occurs.&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;componentDidMount()&lt;/code&gt; is invoked immediately after mounting occurs. Initialization that requires DOM nodes should go here.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;updating&quot;&gt;Updating&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;componentWillReceiveProps(object nextProps)&lt;/code&gt; is invoked when a mounted component receives new props. This method should be used to compare &lt;code&gt;this.props&lt;/code&gt; and &lt;code&gt;nextProps&lt;/code&gt; to perform state transitions using &lt;code&gt;this.setState()&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;shouldComponentUpdate(object nextProps, object nextState): boolean&lt;/code&gt; is invoked when a component decides whether any changes warrant an update to the DOM. Implement this as an optimization to compare &lt;code&gt;this.props&lt;/code&gt; with &lt;code&gt;nextProps&lt;/code&gt; and &lt;code&gt;this.state&lt;/code&gt; with &lt;code&gt;nextState&lt;/code&gt; and return false if React should skip updating.&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;componentWillUpdate(object nextProps, object nextState)&lt;/code&gt; is invoked immediately before updating occurs. You cannot call &lt;code&gt;this.setState()&lt;/code&gt; here.&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;componentDidUpdate(object prevProps, object prevState)&lt;/code&gt; is invoked immediately after updating occurs.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;unmounting&quot;&gt;Unmounting&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;componentWillUnmount()&lt;/code&gt; is invoked immediately before a component is unmounted and destroyed. Cleanup should go here.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;mounted-methods&quot;&gt;Mounted Methods&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;Mounted&lt;/em&gt; composite components also support the following methods:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;findDOMNode(): DOMElement&lt;/code&gt; can be invoked on any mounted component in order to obtain a reference to its rendered DOM node.&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;forceUpdate()&lt;/code&gt; can be invoked on any mounted component when you know that some deeper aspect of the component’s state has changed without using &lt;code&gt;this.setState()&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;browser-support-and-polyfills&quot;&gt;Browser Support and Polyfills&lt;/h2&gt;

&lt;p&gt;At Facebook, we support older browsers, including IE8. We’ve had polyfills in place for a long time to allow us to write forward-thinking JS. This means we don’t have a bunch of hacks scattered throughout our codebase and we can still expect our code to “just work”. For example, instead of seeing &lt;code&gt;+new Date()&lt;/code&gt;, we can just write &lt;code&gt;Date.now()&lt;/code&gt;. Since the open source React is the same as what we use internally, we’ve carried over this philosophy of using forward thinking JS.&lt;/p&gt;

&lt;p&gt;In addition to that philosophy, we’ve also taken the stance that we, as authors of a JS library, should not be shipping polyfills as a part of our library. If every library did this, there’s a good chance you’d be sending down the same polyfill multiple times, which could be a sizable chunk of dead code. If your product needs to support older browsers, chances are you’re already using something like &lt;a href=&quot;https://github.com/es-shims/es5-shim&quot;&gt;es5-shim&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&quot;polyfills-needed-to-support-older-browsers&quot;&gt;Polyfills Needed to Support Older Browsers&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;es5-shim.js&lt;/code&gt; from &lt;a href=&quot;https://github.com/es-shims/es5-shim&quot;&gt;kriskowal’s es5-shim&lt;/a&gt; provides the following that React needs:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;Array.isArray&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;Array.prototype.every&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;Array.prototype.forEach&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;Array.prototype.indexOf&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;Array.prototype.map&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;Date.now&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;Function.prototype.bind&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;Object.keys&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;String.prototype.split&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;String.prototype.trim&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;es5-sham.js&lt;/code&gt;, also from &lt;a href=&quot;https://github.com/es-shims/es5-shim&quot;&gt;kriskowal’s es5-shim&lt;/a&gt;, provides the following that React needs:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;Object.create&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;Object.freeze&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The unminified build of React needs the following from &lt;a href=&quot;https://github.com/paulmillr/console-polyfill&quot;&gt;paulmillr’s console-polyfill&lt;/a&gt;.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;console.*&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;When using HTML5 elements in IE8 including &lt;code&gt;&amp;lt;section&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;article&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;nav&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;header&amp;gt;&lt;/code&gt;, and &lt;code&gt;&amp;lt;footer&amp;gt;&lt;/code&gt;, it’s also necessary to include &lt;a href=&quot;https://github.com/aFarkas/html5shiv&quot;&gt;html5shiv&lt;/a&gt; or a similar script.&lt;/p&gt;

&lt;h3 id=&quot;cross-browser-issues&quot;&gt;Cross-browser Issues&lt;/h3&gt;

&lt;p&gt;Although React is pretty good at abstracting browser differences, some browsers are limited or present quirky behaviors that we couldn’t find a workaround for.&lt;/p&gt;

&lt;h4 id=&quot;onscroll-event-on-ie8&quot;&gt;onScroll event on IE8&lt;/h4&gt;

&lt;p&gt;On IE8 the &lt;code&gt;onScroll&lt;/code&gt; event doesn’t bubble and IE8 doesn’t have an API to define handlers to the capturing phase of an event, meaning there is no way for React to listen to these events.
Currently a handler to this event is ignored on IE8.&lt;/p&gt;

&lt;p&gt;See the &lt;a href=&quot;https://github.com/facebook/react/issues/631&quot;&gt;onScroll doesn’t work in IE8&lt;/a&gt; GitHub issue for more information.&lt;/p&gt;

&lt;ul&gt;
  
&lt;/ul&gt;

</description>
        <pubDate>Fri, 01 Jan 3008 00:00:00 +0800</pubDate>
        <link>/help-doc/v006/articles/working-with-the-browser.html</link>
        <guid isPermaLink="true">/help-doc/v006/articles/working-with-the-browser.html</guid>
        
        
        <category>guides</category>
        
      </item>
    
      <item>
        <title>Forms</title>
        <description>&lt;p&gt;Form components such as &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;textarea&amp;gt;&lt;/code&gt;, and &lt;code&gt;&amp;lt;option&amp;gt;&lt;/code&gt; differ from other native components because they can be mutated via user interactions. These components provide interfaces that make it easier to manage forms in response to user interactions.&lt;/p&gt;

&lt;p&gt;For information on events on &lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt; see &lt;a href=&quot;/react/docs/events.html#form-events&quot;&gt;Form Events&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;interactive-props&quot;&gt;Interactive Props&lt;/h2&gt;

&lt;p&gt;Form components support a few props that are affected via user interactions:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;value&lt;/code&gt;, supported by &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;textarea&amp;gt;&lt;/code&gt; components.&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;checked&lt;/code&gt;, supported by &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; components of type &lt;code&gt;checkbox&lt;/code&gt; or &lt;code&gt;radio&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;selected&lt;/code&gt;, supported by &lt;code&gt;&amp;lt;option&amp;gt;&lt;/code&gt; components.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In HTML, the value of &lt;code&gt;&amp;lt;textarea&amp;gt;&lt;/code&gt; is set via children. In React, you should use &lt;code&gt;value&lt;/code&gt; instead.&lt;/p&gt;

&lt;p&gt;Form components allow listening for changes by setting a callback to the &lt;code&gt;onChange&lt;/code&gt; prop. The &lt;code&gt;onChange&lt;/code&gt; prop works across browsers to fire in response to user interactions when:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;The &lt;code&gt;value&lt;/code&gt; of &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;lt;textarea&amp;gt;&lt;/code&gt; changes.&lt;/li&gt;
  &lt;li&gt;The &lt;code&gt;checked&lt;/code&gt; state of &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; changes.&lt;/li&gt;
  &lt;li&gt;The &lt;code&gt;selected&lt;/code&gt; state of &lt;code&gt;&amp;lt;option&amp;gt;&lt;/code&gt; changes.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Like all DOM events, the &lt;code&gt;onChange&lt;/code&gt; prop is supported on all native components and can be used to listen to bubbled change events.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Note:&lt;/p&gt;

  &lt;p&gt;For &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;textarea&amp;gt;&lt;/code&gt;, &lt;code&gt;onChange&lt;/code&gt; supersedes — and should generally be used instead of — the DOM’s built-in &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/GlobalEventHandlers/oninput&quot;&gt;&lt;code&gt;oninput&lt;/code&gt;&lt;/a&gt; event handler.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;controlled-components&quot;&gt;Controlled Components&lt;/h2&gt;

&lt;p&gt;An &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; with &lt;code&gt;value&lt;/code&gt; set is a &lt;em&gt;controlled&lt;/em&gt; component. In a controlled &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt;, the value of the rendered element will always reflect the &lt;code&gt;value&lt;/code&gt; prop. For example:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;javascript
  render: function() {
    return &amp;lt;input type=&quot;text&quot; value=&quot;Hello!&quot; /&amp;gt;;
  }
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;This will render an input that always has a value of &lt;code&gt;Hello!&lt;/code&gt;. Any user input will have no effect on the rendered element because React has declared the value to be &lt;code&gt;Hello!&lt;/code&gt;. If you wanted to update the value in response to user input, you could use the &lt;code&gt;onChange&lt;/code&gt; event:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;javascript
  getInitialState: function() {
    return {value: &#39;Hello!&#39;};
  },
  handleChange: function(event) {
    this.setState({value: event.target.value});
  },
  render: function() {
    var value = this.state.value;
    return &amp;lt;input type=&quot;text&quot; value={value} onChange={this.handleChange} /&amp;gt;;
  }
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;In this example, we are simply accepting the newest value provided by the user and updating the &lt;code&gt;value&lt;/code&gt; prop of the &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; component. This pattern makes it easy to implement interfaces that respond to or validate user interactions. For example:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;javascript
  handleChange: function(event) {
    this.setState({value: event.target.value.substr(0, 140)});
  }
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;This would accept user input but truncate the value to the first 140 characters.&lt;/p&gt;

&lt;h2 id=&quot;uncontrolled-components&quot;&gt;Uncontrolled Components&lt;/h2&gt;

&lt;p&gt;An &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; that does not supply a &lt;code&gt;value&lt;/code&gt; (or sets it to &lt;code&gt;null&lt;/code&gt;) is an &lt;em&gt;uncontrolled&lt;/em&gt; component. In an uncontrolled &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt;, the value of the rendered element will reflect the user’s input. For example:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;javascript
  render: function() {
    return &amp;lt;input type=&quot;text&quot; /&amp;gt;;
  }
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;This will render an input that starts off with an empty value. Any user input will be immediately reflected by the rendered element. If you wanted to listen to updates to the value, you could use the &lt;code&gt;onChange&lt;/code&gt; event just like you can with controlled components.&lt;/p&gt;

&lt;p&gt;If you want to initialize the component with a non-empty value, you can supply a &lt;code&gt;defaultValue&lt;/code&gt; prop. For example:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;javascript
  render: function() {
    return &amp;lt;input type=&quot;text&quot; defaultValue=&quot;Hello!&quot; /&amp;gt;;
  }
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;This example will function much like the &lt;strong&gt;Controlled Components&lt;/strong&gt; example above.&lt;/p&gt;

&lt;p&gt;Likewise, &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; supports &lt;code&gt;defaultChecked&lt;/code&gt; and &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; supports &lt;code&gt;defaultValue&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&quot;advanced-topics&quot;&gt;Advanced Topics&lt;/h2&gt;

&lt;h3 id=&quot;why-controlled-components&quot;&gt;Why Controlled Components?&lt;/h3&gt;

&lt;p&gt;Using form components such as &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; in React presents a challenge that is absent when writing traditional form HTML. For example, in HTML:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;html
  &amp;lt;input type=&quot;text&quot; name=&quot;title&quot; value=&quot;Untitled&quot; /&amp;gt;
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;This renders an input &lt;em&gt;initialized&lt;/em&gt; with the value, &lt;code&gt;Untitled&lt;/code&gt;. When the user updates the input, the node’s value &lt;em&gt;property&lt;/em&gt; will change. However, &lt;code&gt;node.getAttribute(&#39;value&#39;)&lt;/code&gt; will still return the value used at initialization time, &lt;code&gt;Untitled&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Unlike HTML, React components must represent the state of the view at any point in time and not only at initialization time. For example, in React:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;javascript
  render: function() {
    return &amp;lt;input type=&quot;text&quot; name=&quot;title&quot; value=&quot;Untitled&quot; /&amp;gt;;
  }
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Since this method describes the view at any point in time, the value of the text input should &lt;em&gt;always&lt;/em&gt; be &lt;code&gt;Untitled&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&quot;why-textarea-value&quot;&gt;Why Textarea Value?&lt;/h3&gt;

&lt;p&gt;In HTML, the value of &lt;code&gt;&amp;lt;textarea&amp;gt;&lt;/code&gt; is usually set using its children:&lt;/p&gt;

&lt;p&gt;```html
  &lt;!-- counterexample: DO NOT DO THIS! --&gt;&lt;/p&gt;
&lt;textarea name=&quot;description&quot;&gt;This is the description.&lt;/textarea&gt;
&lt;p&gt;```&lt;/p&gt;

&lt;p&gt;For HTML, this easily allows developers to supply multiline values. However, since React is JavaScript, we do not have string limitations and can use &lt;code&gt;\n&lt;/code&gt; if we want newlines. In a world where we have &lt;code&gt;value&lt;/code&gt; and &lt;code&gt;defaultValue&lt;/code&gt;, it is ambiguous what role children play. For this reason, you should not use children when setting &lt;code&gt;&amp;lt;textarea&amp;gt;&lt;/code&gt; values:&lt;/p&gt;

&lt;p&gt;```javascript&lt;/p&gt;
&lt;textarea name=&quot;description&quot; value=&quot;This is a description.&quot; /&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;p&gt;If you &lt;em&gt;do&lt;/em&gt; decide to use children, they will behave like &lt;code&gt;defaultValue&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&quot;why-select-value&quot;&gt;Why Select Value?&lt;/h3&gt;

&lt;p&gt;The selected &lt;code&gt;&amp;lt;option&amp;gt;&lt;/code&gt; in an HTML &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; is normally specified through that option’s &lt;code&gt;selected&lt;/code&gt; attribute. In React, in order to make components easier to manipulate, the following format is adopted instead:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;javascript
  &amp;lt;select value=&quot;B&quot;&amp;gt;
    &amp;lt;option value=&quot;A&quot;&amp;gt;Apple&amp;lt;/option&amp;gt;
    &amp;lt;option value=&quot;B&quot;&amp;gt;Banana&amp;lt;/option&amp;gt;
    &amp;lt;option value=&quot;C&quot;&amp;gt;Cranberry&amp;lt;/option&amp;gt;
  &amp;lt;/select&amp;gt;
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;To make an uncontrolled component, &lt;code&gt;defaultValue&lt;/code&gt; is used instead.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Note:&lt;/p&gt;

  &lt;p&gt;You can pass an array into the &lt;code&gt;value&lt;/code&gt; attribute, allowing you to select multiple options in a &lt;code&gt;select&lt;/code&gt; tag: &lt;code&gt;&amp;lt;select multiple={true} value={[&#39;B&#39;, &#39;C&#39;]}&amp;gt;&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Thu, 01 Jan 3007 00:00:00 +0800</pubDate>
        <link>/help-doc/v006/articles/forms.html</link>
        <guid isPermaLink="true">/help-doc/v006/articles/forms.html</guid>
        
        
        <category>guides</category>
        
      </item>
    
      <item>
        <title>Transferring Props</title>
        <description>&lt;p&gt;It’s a common pattern in React to wrap a component in an abstraction. The outer component exposes a simple property to do something that might have more complex implementation details.&lt;/p&gt;

&lt;p&gt;You can use &lt;a href=&quot;/react/docs/jsx-spread.html&quot;&gt;JSX spread attributes&lt;/a&gt; to merge the old props with additional values:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;javascript
&amp;lt;Component {...this.props} more=&quot;values&quot; /&amp;gt;
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;If you don’t use JSX, you can use any object helper such as ES6 &lt;code&gt;Object.assign&lt;/code&gt; or Underscore &lt;code&gt;_.extend&lt;/code&gt;:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;javascript
React.createElement(Component, Object.assign({}, this.props, { more: &#39;values&#39; }));
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;The rest of this tutorial explains best practices. It uses JSX and experimental ES7 syntax.&lt;/p&gt;

&lt;h2 id=&quot;manual-transfer&quot;&gt;Manual Transfer&lt;/h2&gt;

&lt;p&gt;Most of the time you should explicitly pass the properties down. That ensures that you only expose a subset of the inner API, one that you know will work.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;javascript
var FancyCheckbox = React.createClass({
  render: function() {
    var fancyClass = this.props.checked ? &#39;FancyChecked&#39; : &#39;FancyUnchecked&#39;;
    return (
      &amp;lt;div className={fancyClass} onClick={this.props.onClick}&amp;gt;
        {this.props.children}
      &amp;lt;/div&amp;gt;
    );
  }
});
React.render(
  &amp;lt;FancyCheckbox checked={true} onClick={console.log.bind(console)}&amp;gt;
    Hello world!
  &amp;lt;/FancyCheckbox&amp;gt;,
  document.getElementById(&#39;example&#39;)
);
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;But what about the &lt;code&gt;name&lt;/code&gt; prop? Or the &lt;code&gt;title&lt;/code&gt; prop? Or &lt;code&gt;onMouseOver&lt;/code&gt;?&lt;/p&gt;

&lt;h2 id=&quot;transferring-with--in-jsx&quot;&gt;Transferring with &lt;code&gt;...&lt;/code&gt; in JSX&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;NOTE:&lt;/p&gt;

  &lt;p&gt;In the example below, the &lt;code&gt;--harmony &lt;/code&gt; flag is required as this syntax is an experimental ES7 syntax. If using the in-browser JSX transformer, simply open your script with &lt;code&gt;&amp;lt;script type=&quot;text/jsx;harmony=true&quot;&amp;gt;&lt;/code&gt;. See the &lt;a href=&quot;/react/docs/transferring-props.html#rest-and-spread-properties-...&quot;&gt;Rest and Spread Properties …&lt;/a&gt; section below for more details.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Sometimes it’s fragile and tedious to pass every property along. In that case you can use &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment&quot;&gt;destructuring assignment&lt;/a&gt; with rest properties to extract a set of unknown properties.&lt;/p&gt;

&lt;p&gt;List out all the properties that you would like to consume, followed by &lt;code&gt;...other&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;javascript
var { checked, ...other } = this.props;
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;This ensures that you pass down all the props EXCEPT the ones you’re consuming yourself.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;javascript
var FancyCheckbox = React.createClass({
  render: function() {
    var { checked, ...other } = this.props;
    var fancyClass = checked ? &#39;FancyChecked&#39; : &#39;FancyUnchecked&#39;;
    // `other` contains { onClick: console.log } but not the checked property
    return (
      &amp;lt;div {...other} className={fancyClass} /&amp;gt;
    );
  }
});
React.render(
  &amp;lt;FancyCheckbox checked={true} onClick={console.log.bind(console)}&amp;gt;
    Hello world!
  &amp;lt;/FancyCheckbox&amp;gt;,
  document.getElementById(&#39;example&#39;)
);
&lt;/code&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;NOTE:&lt;/p&gt;

  &lt;p&gt;In the example above, the &lt;code&gt;checked&lt;/code&gt; prop is also a valid DOM attribute. If you didn’t use destructuring in this way you might inadvertently pass it along.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Always use the destructuring pattern when transferring unknown &lt;code&gt;other&lt;/code&gt; props.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;javascript
var FancyCheckbox = React.createClass({
  render: function() {
    var fancyClass = this.props.checked ? &#39;FancyChecked&#39; : &#39;FancyUnchecked&#39;;
    // ANTI-PATTERN: `checked` would be passed down to the inner component
    return (
      &amp;lt;div {...this.props} className={fancyClass} /&amp;gt;
    );
  }
});
&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;consuming-and-transferring-the-same-prop&quot;&gt;Consuming and Transferring the Same Prop&lt;/h2&gt;

&lt;p&gt;If your component wants to consume a property but also wants to pass it along, you can repass it explicitly with &lt;code&gt;checked={checked}&lt;/code&gt;. This is preferable to passing the full &lt;code&gt;this.props&lt;/code&gt; object since it’s easier to refactor and lint.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;javascript
var FancyCheckbox = React.createClass({
  render: function() {
    var { checked, title, ...other } = this.props;
    var fancyClass = checked ? &#39;FancyChecked&#39; : &#39;FancyUnchecked&#39;;
    var fancyTitle = checked ? &#39;X &#39; + title : &#39;O &#39; + title;
    return (
      &amp;lt;label&amp;gt;
        &amp;lt;input {...other}
          checked={checked}
          className={fancyClass}
          type=&quot;checkbox&quot;
        /&amp;gt;
        {fancyTitle}
      &amp;lt;/label&amp;gt;
    );
  }
});
&lt;/code&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;NOTE:&lt;/p&gt;

  &lt;p&gt;Order matters. By putting the &lt;code&gt;{...other}&lt;/code&gt; before your JSX props you ensure that the consumer of your component can’t override them. In the example above we have guaranteed that the input will be of type &lt;code&gt;&quot;checkbox&quot;&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;rest-and-spread-properties-&quot;&gt;Rest and Spread Properties &lt;code&gt;...&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;Rest properties allow you to extract the remaining properties from an object into a new object. It excludes every other property listed in the destructuring pattern.&lt;/p&gt;

&lt;p&gt;This is an experimental implementation of an &lt;a href=&quot;https://github.com/sebmarkbage/ecmascript-rest-spread&quot;&gt;ES7 proposal&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;javascript
var { x, y, ...z } = { x: 1, y: 2, a: 3, b: 4 };
x; // 1
y; // 2
z; // { a: 3, b: 4 }
&lt;/code&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Note:&lt;/p&gt;

  &lt;p&gt;Use the &lt;a href=&quot;https://www.npmjs.com/package/react-tools&quot;&gt;JSX command-line tool&lt;/a&gt; with the &lt;code&gt;--harmony&lt;/code&gt; flag to activate the experimental ES7 syntax.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;transferring-with-underscore&quot;&gt;Transferring with Underscore&lt;/h2&gt;

&lt;p&gt;If you don’t use JSX, you can use a library to achieve the same pattern. Underscore supports &lt;code&gt;_.omit&lt;/code&gt; to filter out properties and &lt;code&gt;_.extend&lt;/code&gt; to copy properties onto a new object.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;javascript
var FancyCheckbox = React.createClass({
  render: function() {
    var checked = this.props.checked;
    var other = _.omit(this.props, &#39;checked&#39;);
    var fancyClass = checked ? &#39;FancyChecked&#39; : &#39;FancyUnchecked&#39;;
    return (
      React.DOM.div(_.extend({}, other, { className: fancyClass }))
    );
  }
});
&lt;/code&gt;&lt;/p&gt;
</description>
        <pubDate>Wed, 01 Jan 3006 00:00:00 +0800</pubDate>
        <link>/help-doc/v006/articles/transferring-props.html</link>
        <guid isPermaLink="true">/help-doc/v006/articles/transferring-props.html</guid>
        
        
        <category>guides</category>
        
      </item>
    
      <item>
        <title>Reusable Components</title>
        <description>&lt;p&gt;When designing interfaces, break down the common design elements (buttons, form fields, layout components, etc.) into reusable components with well-defined interfaces. That way, the next time you need to build some UI, you can write much less code. This means faster development time, fewer bugs, and fewer bytes down the wire.&lt;/p&gt;

&lt;h2 id=&quot;prop-validation&quot;&gt;Prop Validation&lt;/h2&gt;

&lt;p&gt;As your app grows it’s helpful to ensure that your components are used correctly. We do this by allowing you to specify &lt;code&gt;propTypes&lt;/code&gt;. &lt;code&gt;React.PropTypes&lt;/code&gt; exports a range of validators that can be used to make sure the data you receive is valid. When an invalid value is provided for a prop, a warning will be shown in the JavaScript console. Note that for performance reasons &lt;code&gt;propTypes&lt;/code&gt; is only checked in development mode. Here is an example documenting the different validators provided:&lt;/p&gt;

&lt;p&gt;```javascript
React.createClass({
  propTypes: {
    // You can declare that a prop is a specific JS primitive. By default, these
    // are all optional.
    optionalArray: React.PropTypes.array,
    optionalBool: React.PropTypes.bool,
    optionalFunc: React.PropTypes.func,
    optionalNumber: React.PropTypes.number,
    optionalObject: React.PropTypes.object,
    optionalString: React.PropTypes.string,&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// Anything that can be rendered: numbers, strings, elements or an array
// (or fragment) containing these types.
optionalNode: React.PropTypes.node,

// A React element.
optionalElement: React.PropTypes.element,

// You can also declare that a prop is an instance of a class. This uses
// JS&#39;s instanceof operator.
optionalMessage: React.PropTypes.instanceOf(Message),

// You can ensure that your prop is limited to specific values by treating
// it as an enum.
optionalEnum: React.PropTypes.oneOf([&#39;News&#39;, &#39;Photos&#39;]),

// An object that could be one of many types
optionalUnion: React.PropTypes.oneOfType([
  React.PropTypes.string,
  React.PropTypes.number,
  React.PropTypes.instanceOf(Message)
]),

// An array of a certain type
optionalArrayOf: React.PropTypes.arrayOf(React.PropTypes.number),

// An object with property values of a certain type
optionalObjectOf: React.PropTypes.objectOf(React.PropTypes.number),

// An object taking on a particular shape
optionalObjectWithShape: React.PropTypes.shape({
  color: React.PropTypes.string,
  fontSize: React.PropTypes.number
}),

// You can chain any of the above with `isRequired` to make sure a warning
// is shown if the prop isn&#39;t provided.
requiredFunc: React.PropTypes.func.isRequired,

// A value of any data type
requiredAny: React.PropTypes.any.isRequired,

// You can also specify a custom validator. It should return an Error
// object if the validation fails. Don&#39;t `console.warn` or throw, as this
// won&#39;t work inside `oneOfType`.
customProp: function(props, propName, componentName) {
  if (!/matchme/.test(props[propName])) {
    return new Error(&#39;Validation failed!&#39;);
  }
}   },   /* ... */ }); ```
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;default-prop-values&quot;&gt;Default Prop Values&lt;/h2&gt;

&lt;p&gt;React lets you define default values for your &lt;code&gt;props&lt;/code&gt; in a very declarative way:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;javascript
var ComponentWithDefaultProps = React.createClass({
  getDefaultProps: function() {
    return {
      value: &#39;default value&#39;
    };
  }
  /* ... */
});
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;The result of &lt;code&gt;getDefaultProps()&lt;/code&gt; will be cached and used to ensure that &lt;code&gt;this.props.value&lt;/code&gt; will have a value if it was not specified by the parent component. This allows you to safely just use your props without having to write repetitive and fragile code to handle that yourself.&lt;/p&gt;

&lt;h2 id=&quot;transferring-props-a-shortcut&quot;&gt;Transferring Props: A Shortcut&lt;/h2&gt;

&lt;p&gt;A common type of React component is one that extends a basic HTML element in a simple way. Often you’ll want to copy any HTML attributes passed to your component to the underlying HTML element to save typing. You can use the JSX &lt;em&gt;spread&lt;/em&gt; syntax to achieve this:&lt;/p&gt;

&lt;p&gt;```javascript
var CheckLink = React.createClass({
  render: function() {
    // This takes any props passed to CheckLink and copies them to &lt;a&gt;
    return &amp;lt;a {…this.props}&amp;gt;{‘√ ‘}{this.props.children}&lt;/a&gt;;
  }
});&lt;/p&gt;

&lt;p&gt;React.render(&lt;/p&gt;
&lt;checklink href=&quot;/checked.html&quot;&gt;
    Click here!
  &lt;/checklink&gt;
&lt;p&gt;,
  document.getElementById(‘example’)
);
```&lt;/p&gt;

&lt;h2 id=&quot;single-child&quot;&gt;Single Child&lt;/h2&gt;

&lt;p&gt;With &lt;code&gt;React.PropTypes.element&lt;/code&gt; you can specify that only a single child can be passed to
a component as children.&lt;/p&gt;

&lt;p&gt;```javascript
var MyComponent = React.createClass({
  propTypes: {
    children: React.PropTypes.element.isRequired
  },&lt;/p&gt;

&lt;p&gt;render: function() {
    return (
      &amp;lt;div&amp;gt;
        {this.props.children} // This must be exactly one element or it will throw.
      &amp;lt;/div&amp;gt;
    );
  }&lt;/p&gt;

&lt;p&gt;});
```&lt;/p&gt;

&lt;h2 id=&quot;mixins&quot;&gt;Mixins&lt;/h2&gt;

&lt;p&gt;Components are the best way to reuse code in React, but sometimes very different components may share some common functionality. These are sometimes called &lt;a href=&quot;https://en.wikipedia.org/wiki/Cross-cutting_concern&quot;&gt;cross-cutting concerns&lt;/a&gt;. React provides &lt;code&gt;mixins&lt;/code&gt; to solve this problem.&lt;/p&gt;

&lt;p&gt;One common use case is a component wanting to update itself on a time interval. It’s easy to use &lt;code&gt;setInterval()&lt;/code&gt;, but it’s important to cancel your interval when you don’t need it anymore to save memory. React provides &lt;a href=&quot;/react/docs/working-with-the-browser.html#component-lifecycle&quot;&gt;lifecycle methods&lt;/a&gt; that let you know when a component is about to be created or destroyed. Let’s create a simple mixin that uses these methods to provide an easy &lt;code&gt;setInterval()&lt;/code&gt; function that will automatically get cleaned up when your component is destroyed.&lt;/p&gt;

&lt;p&gt;```javascript
var SetIntervalMixin = {
  componentWillMount: function() {
    this.intervals = [];
  },
  setInterval: function() {
    this.intervals.push(setInterval.apply(null, arguments));
  },
  componentWillUnmount: function() {
    this.intervals.forEach(clearInterval);
  }
};&lt;/p&gt;

&lt;p&gt;var TickTock = React.createClass({
  mixins: [SetIntervalMixin], // Use the mixin
  getInitialState: function() {
    return {seconds: 0};
  },
  componentDidMount: function() {
    this.setInterval(this.tick, 1000); // Call a method on the mixin
  },
  tick: function() {
    this.setState({seconds: this.state.seconds + 1});
  },
  render: function() {
    return (
      &amp;lt;p&amp;gt;
        React has been running for {this.state.seconds} seconds.
      &amp;lt;/p&amp;gt;
    );
  }
});&lt;/p&gt;

&lt;p&gt;React.render(&lt;/p&gt;
&lt;ticktock /&gt;
&lt;p&gt;,
  document.getElementById(‘example’)
);
```&lt;/p&gt;

&lt;p&gt;A nice feature of mixins is that if a component is using multiple mixins and several mixins define the same lifecycle method (i.e. several mixins want to do some cleanup when the component is destroyed), all of the lifecycle methods are guaranteed to be called. Methods defined on mixins run in the order mixins were listed, followed by a method call on the component.&lt;/p&gt;

&lt;h2 id=&quot;es6-classes&quot;&gt;ES6 Classes&lt;/h2&gt;

&lt;p&gt;You may also define your React classes as a plain JavaScript class. For example using ES6 class syntax:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;javascript
class HelloMessage extends React.Component {
  render() {
    return &amp;lt;div&amp;gt;Hello {this.props.name}&amp;lt;/div&amp;gt;;
  }
}
React.render(&amp;lt;HelloMessage name=&quot;Sebastian&quot; /&amp;gt;, mountNode);
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;The API is similar to &lt;code&gt;React.createClass&lt;/code&gt; with the exception of &lt;code&gt;getInitialState&lt;/code&gt;. Instead of providing a separate &lt;code&gt;getInitialState&lt;/code&gt; method, you set up your own &lt;code&gt;state&lt;/code&gt; property in the constructor.&lt;/p&gt;

&lt;p&gt;Another difference is that &lt;code&gt;propTypes&lt;/code&gt; and &lt;code&gt;defaultProps&lt;/code&gt; are defined as properties on the constructor instead of in the class body.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;javascript
export class Counter extends React.Component {
  constructor(props) {
    super(props);
    this.state = {count: props.initialCount};
  }
  tick() {
    this.setState({count: this.state.count + 1});
  }
  render() {
    return (
      &amp;lt;div onClick={this.tick.bind(this)}&amp;gt;
        Clicks: {this.state.count}
      &amp;lt;/div&amp;gt;
    );
  }
}
Counter.propTypes = { initialCount: React.PropTypes.number };
Counter.defaultProps = { initialCount: 0 };
&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;no-autobinding&quot;&gt;No Autobinding&lt;/h3&gt;

&lt;p&gt;Methods follow the same semantics as regular ES6 classes, meaning that they don’t automatically bind &lt;code&gt;this&lt;/code&gt; to the instance. You’ll have to explicitly use &lt;code&gt;.bind(this)&lt;/code&gt; or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions&quot;&gt;arrow functions&lt;/a&gt; &lt;code&gt;=&amp;gt;&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&quot;no-mixins&quot;&gt;No Mixins&lt;/h3&gt;

&lt;p&gt;Unfortunately ES6 launched without any mixin support. Therefore, there is no support for mixins when you use React with ES6 classes. Instead, we’re working on making it easier to support such use cases without resorting to mixins.&lt;/p&gt;
</description>
        <pubDate>Tue, 01 Jan 3005 00:00:00 +0800</pubDate>
        <link>/help-doc/v006/articles/reusable-components.html</link>
        <guid isPermaLink="true">/help-doc/v006/articles/reusable-components.html</guid>
        
        
        <category>guides</category>
        
      </item>
    
      <item>
        <title>Multiple Components</title>
        <description>&lt;p&gt;So far, we’ve looked at how to write a single component to display data and handle user input. Next let’s examine one of React’s finest features: composability.&lt;/p&gt;

&lt;h2 id=&quot;motivation-separation-of-concerns&quot;&gt;Motivation: Separation of Concerns&lt;/h2&gt;

&lt;p&gt;By building modular components that reuse other components with well-defined interfaces, you get much of the same benefits that you get by using functions or classes. Specifically you can &lt;em&gt;separate the different concerns&lt;/em&gt; of your app however you please simply by building new components. By building a custom component library for your application, you are expressing your UI in a way that best fits your domain.&lt;/p&gt;

&lt;h2 id=&quot;composition-example&quot;&gt;Composition Example&lt;/h2&gt;

&lt;p&gt;Let’s create a simple Avatar component which shows a profile picture and username using the Facebook Graph API.&lt;/p&gt;

&lt;p&gt;```javascript
var Avatar = React.createClass({
  render: function() {
    return (
      &amp;lt;div&amp;gt;
        &amp;lt;ProfilePic username={this.props.username} /&amp;gt;
        &amp;lt;ProfileLink username={this.props.username} /&amp;gt;
      &amp;lt;/div&amp;gt;
    );
  }
});&lt;/p&gt;

&lt;p&gt;var ProfilePic = React.createClass({
  render: function() {
    return (
      &amp;lt;img src={‘https://graph.facebook.com/’ + this.props.username + ‘/picture’} /&amp;gt;
    );
  }
});&lt;/p&gt;

&lt;p&gt;var ProfileLink = React.createClass({
  render: function() {
    return (
      &amp;lt;a href={‘https://www.facebook.com/’ + this.props.username}&amp;gt;
        {this.props.username}
      &amp;lt;/a&amp;gt;
    );
  }
});&lt;/p&gt;

&lt;p&gt;React.render(&lt;/p&gt;
&lt;avatar username=&quot;pwh&quot; /&gt;
&lt;p&gt;,
  document.getElementById(‘example’)
);
```&lt;/p&gt;

&lt;h2 id=&quot;ownership&quot;&gt;Ownership&lt;/h2&gt;

&lt;p&gt;In the above example, instances of &lt;code&gt;Avatar&lt;/code&gt; &lt;em&gt;own&lt;/em&gt; instances of &lt;code&gt;ProfilePic&lt;/code&gt; and &lt;code&gt;ProfileLink&lt;/code&gt;. In React, &lt;strong&gt;an owner is the component that sets the &lt;code&gt;props&lt;/code&gt; of other components&lt;/strong&gt;. More formally, if a component &lt;code&gt;X&lt;/code&gt; is created in component &lt;code&gt;Y&lt;/code&gt;’s &lt;code&gt;render()&lt;/code&gt; method, it is said that &lt;code&gt;X&lt;/code&gt; is &lt;em&gt;owned by&lt;/em&gt; &lt;code&gt;Y&lt;/code&gt;. As discussed earlier, a component cannot mutate its &lt;code&gt;props&lt;/code&gt; — they are always consistent with what its owner sets them to. This key property leads to UIs that are guaranteed to be consistent.&lt;/p&gt;

&lt;p&gt;It’s important to draw a distinction between the owner-ownee relationship and the parent-child relationship. The owner-ownee relationship is specific to React, while the parent-child relationship is simply the one you know and love from the DOM. In the example above, &lt;code&gt;Avatar&lt;/code&gt; owns the &lt;code&gt;div&lt;/code&gt;, &lt;code&gt;ProfilePic&lt;/code&gt; and &lt;code&gt;ProfileLink&lt;/code&gt; instances, and &lt;code&gt;div&lt;/code&gt; is the &lt;strong&gt;parent&lt;/strong&gt; (but not owner) of the &lt;code&gt;ProfilePic&lt;/code&gt; and &lt;code&gt;ProfileLink&lt;/code&gt; instances.&lt;/p&gt;

&lt;h2 id=&quot;children&quot;&gt;Children&lt;/h2&gt;

&lt;p&gt;When you create a React component instance, you can include additional React components or JavaScript expressions between the opening and closing tags like this:&lt;/p&gt;

&lt;p&gt;```javascript&lt;/p&gt;
&lt;parent&gt;&lt;child /&gt;&lt;/parent&gt;
&lt;p&gt;```&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Parent&lt;/code&gt; can read its children by accessing the special &lt;code&gt;this.props.children&lt;/code&gt; prop. &lt;strong&gt;&lt;code&gt;this.props.children&lt;/code&gt; is an opaque data structure:&lt;/strong&gt; use the &lt;a href=&quot;/react/docs/top-level-api.html#react.children&quot;&gt;React.Children utilities&lt;/a&gt; to manipulate them.&lt;/p&gt;

&lt;h3 id=&quot;child-reconciliation&quot;&gt;Child Reconciliation&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Reconciliation is the process by which React updates the DOM with each new render pass.&lt;/strong&gt; In general, children are reconciled according to the order in which they are rendered. For example, suppose two render passes generate the following respective markup:&lt;/p&gt;

&lt;p&gt;```html
// Render Pass 1&lt;/p&gt;
&lt;card&gt;
  &lt;p&gt;Paragraph 1&lt;/p&gt;
  &lt;p&gt;Paragraph 2&lt;/p&gt;
&lt;/card&gt;
&lt;p&gt;// Render Pass 2&lt;/p&gt;
&lt;card&gt;
  &lt;p&gt;Paragraph 2&lt;/p&gt;
&lt;/card&gt;
&lt;p&gt;```&lt;/p&gt;

&lt;p&gt;Intuitively, &lt;code&gt;&amp;lt;p&amp;gt;Paragraph 1&amp;lt;/p&amp;gt;&lt;/code&gt; was removed. Instead, React will reconcile the DOM by changing the text content of the first child and destroying the last child. React reconciles according to the &lt;em&gt;order&lt;/em&gt; of the children.&lt;/p&gt;

&lt;h3 id=&quot;stateful-children&quot;&gt;Stateful Children&lt;/h3&gt;

&lt;p&gt;For most components, this is not a big deal. However, for stateful components that maintain data in &lt;code&gt;this.state&lt;/code&gt; across render passes, this can be very problematic.&lt;/p&gt;

&lt;p&gt;In most cases, this can be sidestepped by hiding elements instead of destroying them:&lt;/p&gt;

&lt;p&gt;```html
// Render Pass 1&lt;/p&gt;
&lt;card&gt;
  &lt;p&gt;Paragraph 1&lt;/p&gt;
  &lt;p&gt;Paragraph 2&lt;/p&gt;
&lt;/card&gt;
&lt;p&gt;// Render Pass 2&lt;/p&gt;
&lt;card&gt;
  &amp;lt;p style={{display: &#39;none&#39;}}&amp;gt;Paragraph 1
  &lt;p&gt;Paragraph 2&lt;/p&gt;
&lt;/card&gt;
&lt;p&gt;```&lt;/p&gt;

&lt;h3 id=&quot;dynamic-children&quot;&gt;Dynamic Children&lt;/h3&gt;

&lt;p&gt;The situation gets more complicated when the children are shuffled around (as in search results) or if new components are added onto the front of the list (as in streams). In these cases where the identity and state of each child must be maintained across render passes, you can uniquely identify each child by assigning it a &lt;code&gt;key&lt;/code&gt;:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;javascript
  render: function() {
    var results = this.props.results;
    return (
      &amp;lt;ol&amp;gt;
        {results.map(function(result) {
          return &amp;lt;li key={result.id}&amp;gt;{result.text}&amp;lt;/li&amp;gt;;
        })}
      &amp;lt;/ol&amp;gt;
    );
  }
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;When React reconciles the keyed children, it will ensure that any child with &lt;code&gt;key&lt;/code&gt; will be reordered (instead of clobbered) or destroyed (instead of reused).&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;key&lt;/code&gt; should &lt;em&gt;always&lt;/em&gt; be supplied directly to the components in the array, not to the container HTML child of each component in the array:&lt;/p&gt;

&lt;p&gt;```javascript
// WRONG!
var ListItemWrapper = React.createClass({
  render: function() {
    return &amp;lt;li key={this.props.data.id}&amp;gt;{this.props.data.text}&amp;lt;/li&amp;gt;;
  }
});
var MyComponent = React.createClass({
  render: function() {
    return (
      &amp;lt;ul&amp;gt;
        {this.props.results.map(function(result) {
          return &amp;lt;ListItemWrapper data={result}/&amp;gt;;
        })}
      &amp;lt;/ul&amp;gt;
    );
  }
});&lt;/p&gt;

&lt;p&gt;// Correct :)
var ListItemWrapper = React.createClass({
  render: function() {
    return &amp;lt;li&amp;gt;{this.props.data.text}&amp;lt;/li&amp;gt;;
  }
});
var MyComponent = React.createClass({
  render: function() {
    return (
      &amp;lt;ul&amp;gt;
        {this.props.results.map(function(result) {
           return &amp;lt;ListItemWrapper key={result.id} data={result}/&amp;gt;;
        })}
      &amp;lt;/ul&amp;gt;
    );
  }
});
```&lt;/p&gt;

&lt;p&gt;You can also key children by passing a ReactFragment object. See &lt;a href=&quot;create-fragment.html&quot;&gt;Keyed Fragments&lt;/a&gt; for more details.&lt;/p&gt;

&lt;h2 id=&quot;data-flow&quot;&gt;Data Flow&lt;/h2&gt;

&lt;p&gt;In React, data flows from owner to owned component through &lt;code&gt;props&lt;/code&gt; as discussed above. This is effectively one-way data binding: owners bind their owned component’s props to some value the owner has computed based on its &lt;code&gt;props&lt;/code&gt; or &lt;code&gt;state&lt;/code&gt;. Since this process happens recursively, data changes are automatically reflected everywhere they are used.&lt;/p&gt;

&lt;h2 id=&quot;a-note-on-performance&quot;&gt;A Note on Performance&lt;/h2&gt;

&lt;p&gt;You may be thinking that it’s expensive to change data if there are a large number of nodes under an owner. The good news is that JavaScript is fast and &lt;code&gt;render()&lt;/code&gt; methods tend to be quite simple, so in most applications this is extremely fast. Additionally, the bottleneck is almost always the DOM mutation and not JS execution. React will optimize this for you using batching and change detection.&lt;/p&gt;

&lt;p&gt;However, sometimes you really want to have fine-grained control over your performance. In that case, simply override &lt;code&gt;shouldComponentUpdate()&lt;/code&gt; to return false when you want React to skip processing of a subtree. See &lt;a href=&quot;/react/docs/component-specs.html&quot;&gt;the React reference docs&lt;/a&gt; for more information.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Note:&lt;/p&gt;

  &lt;p&gt;If &lt;code&gt;shouldComponentUpdate()&lt;/code&gt; returns false when data has actually changed, React can’t keep your UI in sync. Be sure you know what you’re doing while using it, and only use this function when you have a noticeable performance problem. Don’t underestimate how fast JavaScript is relative to the DOM.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Sun, 01 Jan 3004 00:00:00 +0800</pubDate>
        <link>/help-doc/v006/articles/multiple-components.html</link>
        <guid isPermaLink="true">/help-doc/v006/articles/multiple-components.html</guid>
        
        
        <category>guides</category>
        
      </item>
    
      <item>
        <title>Interactivity and Dynamic UIs</title>
        <description>&lt;p&gt;You’ve already &lt;a href=&quot;/react/docs/displaying-data.html&quot;&gt;learned how to display data&lt;/a&gt; with React. Now let’s look at how to make our UIs interactive.&lt;/p&gt;

&lt;h2 id=&quot;a-simple-example&quot;&gt;A Simple Example&lt;/h2&gt;

&lt;p&gt;```javascript
var LikeButton = React.createClass({
  getInitialState: function() {
    return {liked: false};
  },
  handleClick: function(event) {
    this.setState({liked: !this.state.liked});
  },
  render: function() {
    var text = this.state.liked ? ‘like’ : ‘haven&#39;t liked’;
    return (
      &amp;lt;p onClick={this.handleClick}&amp;gt;
        You {text} this. Click to toggle.
      &amp;lt;/p&amp;gt;
    );
  }
});&lt;/p&gt;

&lt;p&gt;React.render(&lt;/p&gt;
&lt;likebutton /&gt;
&lt;p&gt;,
  document.getElementById(‘example’)
);
```&lt;/p&gt;

&lt;h2 id=&quot;event-handling-and-synthetic-events&quot;&gt;Event Handling and Synthetic Events&lt;/h2&gt;

&lt;p&gt;With React you simply pass your event handler as a camelCased prop similar to how you’d do it in normal HTML. React ensures that all events behave identically in IE8 and above by implementing a synthetic event system. That is, React knows how to bubble and capture events according to the spec, and the events passed to your event handler are guaranteed to be consistent with &lt;a href=&quot;http://www.w3.org/TR/DOM-Level-3-Events/&quot;&gt;the W3C spec&lt;/a&gt;, regardless of which browser you’re using.&lt;/p&gt;

&lt;h2 id=&quot;under-the-hood-autobinding-and-event-delegation&quot;&gt;Under the Hood: Autobinding and Event Delegation&lt;/h2&gt;

&lt;p&gt;Under the hood, React does a few things to keep your code performant and easy to understand.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Autobinding:&lt;/strong&gt; When creating callbacks in JavaScript, you usually need to explicitly bind a method to its instance such that the value of &lt;code&gt;this&lt;/code&gt; is correct. With React, every method is automatically bound to its component instance. React caches the bound method such that it’s extremely CPU and memory efficient. It’s also less typing!&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Event delegation:&lt;/strong&gt; React doesn’t actually attach event handlers to the nodes themselves. When React starts up, it starts listening for all events at the top level using a single event listener. When a component is mounted or unmounted, the event handlers are simply added or removed from an internal mapping. When an event occurs, React knows how to dispatch it using this mapping. When there are no event handlers left in the mapping, React’s event handlers are simple no-ops. To learn more about why this is fast, see &lt;a href=&quot;http://davidwalsh.name/event-delegate&quot;&gt;David Walsh’s excellent blog post&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;components-are-just-state-machines&quot;&gt;Components are Just State Machines&lt;/h2&gt;

&lt;p&gt;React thinks of UIs as simple state machines. By thinking of a UI as being in various states and rendering those states, it’s easy to keep your UI consistent.&lt;/p&gt;

&lt;p&gt;In React, you simply update a component’s state, and then render a new UI based on this new state. React takes care of updating the DOM for you in the most efficient way.&lt;/p&gt;

&lt;h2 id=&quot;how-state-works&quot;&gt;How State Works&lt;/h2&gt;

&lt;p&gt;A common way to inform React of a data change is by calling &lt;code&gt;setState(data, callback)&lt;/code&gt;. This method merges &lt;code&gt;data&lt;/code&gt; into &lt;code&gt;this.state&lt;/code&gt; and re-renders the component. When the component finishes re-rendering, the optional &lt;code&gt;callback&lt;/code&gt; is called. Most of the time you’ll never need to provide a &lt;code&gt;callback&lt;/code&gt; since React will take care of keeping your UI up-to-date for you.&lt;/p&gt;

&lt;h2 id=&quot;what-components-should-have-state&quot;&gt;What Components Should Have State?&lt;/h2&gt;

&lt;p&gt;Most of your components should simply take some data from &lt;code&gt;props&lt;/code&gt; and render it. However, sometimes you need to respond to user input, a server request or the passage of time. For this you use state.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Try to keep as many of your components as possible stateless.&lt;/strong&gt; By doing this you’ll isolate the state to its most logical place and minimize redundancy, making it easier to reason about your application.&lt;/p&gt;

&lt;p&gt;A common pattern is to create several stateless components that just render data, and have a stateful component above them in the hierarchy that passes its state to its children via &lt;code&gt;props&lt;/code&gt;. The stateful component encapsulates all of the interaction logic, while the stateless components take care of rendering data in a declarative way.&lt;/p&gt;

&lt;h2 id=&quot;what-should-go-in-state&quot;&gt;What &lt;em&gt;Should&lt;/em&gt; Go in State?&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;State should contain data that a component’s event handlers may change to trigger a UI update.&lt;/strong&gt; In real apps this data tends to be very small and JSON-serializable. When building a stateful component, think about the minimal possible representation of its state, and only store those properties in &lt;code&gt;this.state&lt;/code&gt;. Inside of &lt;code&gt;render()&lt;/code&gt; simply compute any other information you need based on this state. You’ll find that thinking about and writing applications in this way tends to lead to the most correct application, since adding redundant or computed values to state means that you need to explicitly keep them in sync rather than rely on React computing them for you.&lt;/p&gt;

&lt;h2 id=&quot;what-shouldnt-go-in-state&quot;&gt;What &lt;em&gt;Shouldn’t&lt;/em&gt; Go in State?&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;this.state&lt;/code&gt; should only contain the minimal amount of data needed to represent your UI’s state. As such, it should not contain:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Computed data:&lt;/strong&gt; Don’t worry about precomputing values based on state — it’s easier to ensure that your UI is consistent if you do all computation within &lt;code&gt;render()&lt;/code&gt;. For example, if you have an array of list items in state and you want to render the count as a string, simply render &lt;code&gt;this.state.listItems.length + &#39; list items&#39;&lt;/code&gt; in your &lt;code&gt;render()&lt;/code&gt; method rather than storing it on state.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;React components:&lt;/strong&gt; Build them in &lt;code&gt;render()&lt;/code&gt; based on underlying props and state.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Duplicated data from props:&lt;/strong&gt; Try to use props as the source of truth where possible. One valid use to store props in state is to be able to know its previous values, because props can change over time.&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sat, 01 Jan 3003 00:00:00 +0800</pubDate>
        <link>/help-doc/v006/articles/interactivity-and-dynamic-uis.html</link>
        <guid isPermaLink="true">/help-doc/v006/articles/interactivity-and-dynamic-uis.html</guid>
        
        
        <category>guides</category>
        
      </item>
    
      <item>
        <title>Displaying Data</title>
        <description>&lt;p&gt;The most basic thing you can do with a UI is display some data. React makes it easy to display data and automatically keeps the interface up-to-date when the data changes.&lt;/p&gt;

&lt;h2 id=&quot;getting-started&quot;&gt;Getting Started&lt;/h2&gt;

&lt;p&gt;Let’s look at a really simple example. Create a &lt;code&gt;hello-react.html&lt;/code&gt; file with the following code:&lt;/p&gt;

&lt;p&gt;```html
&amp;lt;!DOCTYPE html&amp;gt;&lt;/p&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;Hello React&lt;/title&gt;
    &lt;script src=&quot;https://fb.me/react-.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;https://fb.me/JSXTransformer-.js&quot;&gt;&lt;/script&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div id=&quot;example&quot;&gt;&lt;/div&gt;
    &lt;script type=&quot;text/jsx&quot;&gt;

      // ** Your code goes here! **

    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
&lt;p&gt;```&lt;/p&gt;

&lt;p&gt;For the rest of the documentation, we’ll just focus on the JavaScript code and assume it’s inserted into a template like the one above. Replace the placeholder comment above with the following JSX:&lt;/p&gt;

&lt;p&gt;```javascript
var HelloWorld = React.createClass({
  render: function() {
    return (
      &amp;lt;p&amp;gt;
        Hello, &lt;input type=&quot;text&quot; placeholder=&quot;Your name here&quot; /&gt;!
        It is {this.props.date.toTimeString()}
      &amp;lt;/p&amp;gt;
    );
  }
});&lt;/p&gt;

&lt;p&gt;setInterval(function() {
  React.render(
    &amp;lt;HelloWorld date={new Date()} /&amp;gt;,
    document.getElementById(‘example’)
  );
}, 500);
```&lt;/p&gt;

&lt;h2 id=&quot;reactive-updates&quot;&gt;Reactive Updates&lt;/h2&gt;

&lt;p&gt;Open &lt;code&gt;hello-react.html&lt;/code&gt; in a web browser and type your name into the text field. Notice that React is only changing the time string in the UI — any input you put in the text field remains, even though you haven’t written any code to manage this behavior. React figures it out for you and does the right thing.&lt;/p&gt;

&lt;p&gt;The way we are able to figure this out is that React does not manipulate the DOM unless it needs to. &lt;strong&gt;It uses a fast, internal mock DOM to perform diffs and computes the most efficient DOM mutation for you.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;The inputs to this component are called &lt;code&gt;props&lt;/code&gt; — short for “properties”. They’re passed as attributes in JSX syntax. You should think of these as immutable within the component, that is, &lt;strong&gt;never write to &lt;code&gt;this.props&lt;/code&gt;&lt;/strong&gt;.&lt;/p&gt;

&lt;h2 id=&quot;components-are-just-like-functions&quot;&gt;Components are Just Like Functions&lt;/h2&gt;

&lt;p&gt;React components are very simple. You can think of them as simple functions that take in &lt;code&gt;props&lt;/code&gt; and &lt;code&gt;state&lt;/code&gt; (discussed later) and render HTML. With this in mind, components are easy to reason about.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Note:&lt;/p&gt;

  &lt;p&gt;&lt;strong&gt;One limitation&lt;/strong&gt;: React components can only render a single root node. If you want to return multiple nodes they &lt;em&gt;must&lt;/em&gt; be wrapped in a single root.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;jsx-syntax&quot;&gt;JSX Syntax&lt;/h2&gt;

&lt;p&gt;We strongly believe that components are the right way to separate concerns rather than “templates” and “display logic.” We think that markup and the code that generates it are intimately tied together. Additionally, display logic is often very complex and using template languages to express it becomes cumbersome.&lt;/p&gt;

&lt;p&gt;We’ve found that the best solution for this problem is to generate HTML and component trees directly from the JavaScript code such that you can use all of the expressive power of a real programming language to build UIs.&lt;/p&gt;

&lt;p&gt;In order to make this easier, we’ve added a very simple, &lt;strong&gt;optional&lt;/strong&gt; HTML-like syntax to create these React tree nodes.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;JSX lets you create JavaScript objects using HTML syntax.&lt;/strong&gt; To generate a link in React using pure JavaScript you’d write:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;React.createElement(&#39;a&#39;, {href: &#39;https://facebook.github.io/react/&#39;}, &#39;Hello!&#39;)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;With JSX this becomes:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;&amp;lt;a href=&quot;https://facebook.github.io/react/&quot;&amp;gt;Hello!&amp;lt;/a&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;We’ve found this has made building React apps easier and designers tend to prefer the syntax, but everyone has their own workflow, so &lt;strong&gt;JSX is not required to use React.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;JSX is very small. To learn more about it, see &lt;a href=&quot;/react/docs/jsx-in-depth.html&quot;&gt;JSX in depth&lt;/a&gt;. Or see the transform in action in &lt;a href=&quot;/react/jsx-compiler.html&quot;&gt;our live JSX compiler&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;JSX is similar to HTML, but not exactly the same. See &lt;a href=&quot;/react/docs/jsx-gotchas.html&quot;&gt;JSX gotchas&lt;/a&gt; for some key differences.&lt;/p&gt;

&lt;p&gt;The easiest way to get started with JSX is to use the in-browser &lt;code&gt;JSXTransformer&lt;/code&gt;. We strongly recommend that you don’t use this in production. You can precompile your code using our command-line &lt;a href=&quot;https://www.npmjs.com/package/react-tools&quot;&gt;react-tools&lt;/a&gt; package.&lt;/p&gt;

&lt;h2 id=&quot;react-without-jsx&quot;&gt;React without JSX&lt;/h2&gt;

&lt;p&gt;JSX is completely optional; you don’t have to use JSX with React. You can create React elements in plain JavaScript using &lt;code&gt;React.createElement&lt;/code&gt;, which takes a tag name or component, a properties object, and variable number of optional child arguments.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;javascript
var child1 = React.createElement(&#39;li&#39;, null, &#39;First Text Content&#39;);
var child2 = React.createElement(&#39;li&#39;, null, &#39;Second Text Content&#39;);
var root = React.createElement(&#39;ul&#39;, { className: &#39;my-list&#39; }, child1, child2);
React.render(root, document.getElementById(&#39;example&#39;));
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;For convenience, you can create short-hand factory functions to create elements from custom components.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;javascript
var Factory = React.createFactory(ComponentClass);
...
var root = Factory({ custom: &#39;prop&#39; });
React.render(root, document.getElementById(&#39;example&#39;));
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;React already has built-in factories for common HTML tags:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;javascript
var root = React.DOM.ul({ className: &#39;my-list&#39; },
             React.DOM.li(null, &#39;Text Content&#39;)
           );
&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
  
&lt;/ul&gt;

</description>
        <pubDate>Fri, 01 Jan 3002 00:00:00 +0800</pubDate>
        <link>/help-doc/v006/articles/displaying-data.html</link>
        <guid isPermaLink="true">/help-doc/v006/articles/displaying-data.html</guid>
        
        
        <category>guides</category>
        
      </item>
    
  </channel>
</rss>
